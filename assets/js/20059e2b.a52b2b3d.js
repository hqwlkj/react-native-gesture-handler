"use strict";(self.webpackChunkreact_native_gesture_handler_docs=self.webpackChunkreact_native_gesture_handler_docs||[]).push([[1010],{3047:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>o,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"under-the-hood/state","title":"Handler State","description":"As described in \\"About Gesture Handlers\\", gesture handlers can be treated as \\"state machines\\".","source":"@site/docs/under-the-hood/state.md","sourceDirName":"under-the-hood","slug":"/under-the-hood/state","permalink":"/react-native-gesture-handler/docs/under-the-hood/state","draft":false,"unlisted":false,"editUrl":"https://github.com/software-mansion/react-native-gesture-handler/edit/main/docs/docs/under-the-hood/state.md","tags":[],"version":"current","frontMatter":{"id":"state","title":"Handler State","sidebar_label":"Handler State"},"sidebar":"tutorialSidebar","previous":{"title":"How does it work?","permalink":"/react-native-gesture-handler/docs/under-the-hood/how-does-it-work"},"next":{"title":"Gesture handlers (legacy)","permalink":"/react-native-gesture-handler/docs/category/gesture-handlers-legacy"}}');var r=t(4848),a=t(8453);const i={id:"state",title:"Handler State",sidebar_label:"Handler State"},d=void 0,l={},c=[{value:"Accessing state",id:"accessing-state",level:2},{value:"State flows",id:"state-flows",level:2},{value:"States",id:"states",level:2},{value:"UNDETERMINED",id:"undetermined",level:3},{value:"FAILED",id:"failed",level:3},{value:"BEGAN",id:"began",level:3},{value:"CANCELLED",id:"cancelled",level:3},{value:"ACTIVE",id:"active",level:3},{value:"END",id:"end",level:3}];function h(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["As described in ",(0,r.jsx)(n.a,{href:"/docs/gesture-handlers/about-handlers",children:'"About Gesture Handlers"'}),", gesture handlers can be treated as ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Finite-state_machine",children:'"state machines"'}),".\nAt any given time, each handler instance has an assigned state that can change when new touch events occur or can be forced to change by the touch system in certain circumstances."]}),"\n",(0,r.jsx)(n.p,{children:"A gesture handler can be in one of the six possible states:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#accessing-state",children:"Accessing state"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#state-flows",children:"State flows"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"#states",children:"States"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#undetermined",children:"UNDETERMINED"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#failed",children:"FAILED"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#began",children:"BEGAN"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#cancelled",children:"CANCELLED"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#active",children:"ACTIVE"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#end",children:"END"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Each state has its own description below."}),"\n",(0,r.jsx)(n.h2,{id:"accessing-state",children:"Accessing state"}),"\n",(0,r.jsxs)(n.p,{children:["We can monitor a handler's state changes by using the ",(0,r.jsx)(n.a,{href:"/docs/gesture-handlers/common-gh#onhandlerstatechange",children:(0,r.jsx)(n.code,{children:"onHandlerStateChange"})})," callback and the destructured ",(0,r.jsx)(n.code,{children:"nativeEvent"})," argument passed to it.\nThis can be done by comparing the ",(0,r.jsx)(n.code,{children:"nativeEvent"}),"'s ",(0,r.jsx)(n.a,{href:"/docs/gesture-handlers/common-gh#state",children:(0,r.jsx)(n.code,{children:"state"})})," attribute to one of the constants exported under the ",(0,r.jsx)(n.code,{children:"State"})," object (see example below)."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"import { State, LongPressGestureHandler } from 'react-native-gesture-handler';\n\nclass Demo extends Component {\n  _handleStateChange = ({ nativeEvent }) => {\n    if (nativeEvent.state === State.ACTIVE) {\n      Alert.alert('Longpress');\n    }\n  };\n  render() {\n    return (\n      <LongPressGestureHandler onHandlerStateChange={this._handleStateChange}>\n        <Text style={styles.buttonText}>Longpress me</Text>\n      </LongPressGestureHandler>\n    );\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"state-flows",children:"State flows"}),"\n",(0,r.jsx)(n.p,{children:"The most typical flow of state is when a gesture handler picks up on an initial touch event then recognizes it then acknowledges its ending then resets itself back to the initial state."}),"\n",(0,r.jsx)(n.p,{children:"The flow looks as follows (longer arrows represent that there are possibly more touch events received before the state changes):"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"#undetermined",children:(0,r.jsx)(n.code,{children:"UNDETERMINED"})})," -> ",(0,r.jsx)(n.a,{href:"#began",children:(0,r.jsx)(n.code,{children:"BEGAN"})})," ------\x3e ",(0,r.jsx)(n.a,{href:"#active",children:(0,r.jsx)(n.code,{children:"ACTIVE"})})," ------\x3e ",(0,r.jsx)(n.a,{href:"#end",children:(0,r.jsx)(n.code,{children:"END"})})," -> ",(0,r.jsx)(n.a,{href:"#undetermined",children:(0,r.jsx)(n.code,{children:"UNDETERMINED"})})]}),"\n",(0,r.jsx)(n.p,{children:"Another possible flow is when a handler receives touches that cause a recognition failure:"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"#undetermined",children:(0,r.jsx)(n.code,{children:"UNDETERMINED"})})," -> ",(0,r.jsx)(n.a,{href:"#began",children:(0,r.jsx)(n.code,{children:"BEGAN"})})," ------\x3e ",(0,r.jsx)(n.a,{href:"#failed",children:(0,r.jsx)(n.code,{children:"FAILED"})})," -> ",(0,r.jsx)(n.a,{href:"#undetermined",children:(0,r.jsx)(n.code,{children:"UNDETERMINED"})})]}),"\n",(0,r.jsx)(n.p,{children:"At last, when a handler does properly recognize the gesture but then is interrupted by the touch system. In that case, the gesture recognition is canceled and the flow looks as follows:"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"#undetermined",children:(0,r.jsx)(n.code,{children:"UNDETERMINED"})})," -> ",(0,r.jsx)(n.a,{href:"#began",children:(0,r.jsx)(n.code,{children:"BEGAN"})})," ------\x3e ",(0,r.jsx)(n.a,{href:"#active",children:(0,r.jsx)(n.code,{children:"ACTIVE"})})," ------\x3e ",(0,r.jsx)(n.a,{href:"#cancelled",children:(0,r.jsx)(n.code,{children:"CANCELLED"})})," -> ",(0,r.jsx)(n.a,{href:"#undetermined",children:(0,r.jsx)(n.code,{children:"UNDETERMINED"})})]}),"\n",(0,r.jsx)(n.h2,{id:"states",children:"States"}),"\n",(0,r.jsx)(n.p,{children:"The section below describes all possible handler states:"}),"\n",(0,r.jsx)(n.h3,{id:"undetermined",children:"UNDETERMINED"}),"\n",(0,r.jsx)(n.p,{children:"This is the initial state of each handler and it goes into this state after it's done recognizing a gesture."}),"\n",(0,r.jsx)(n.h3,{id:"failed",children:"FAILED"}),"\n",(0,r.jsxs)(n.p,{children:["A handler received some touches but for some reason didn't recognize them. For example, if a finger travels more distance than a defined ",(0,r.jsx)(n.code,{children:"maxDist"})," property allows, then the handler won't become active but will fail instead. Afterwards, it's state will be reset to ",(0,r.jsx)(n.code,{children:"UNDETERMINED"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"began",children:"BEGAN"}),"\n",(0,r.jsxs)(n.p,{children:["Handler has started receiving touch stream but hasn't yet received enough data to either ",(0,r.jsx)(n.a,{href:"#failed",children:"fail"})," or ",(0,r.jsx)(n.a,{href:"#active",children:"activate"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"cancelled",children:"CANCELLED"}),"\n",(0,r.jsxs)(n.p,{children:["The gesture recognizer has received a signal (possibly new touches or a command from the touch system controller) resulting in the cancellation of a continuous gesture. The gesture's state will become ",(0,r.jsx)(n.code,{children:"CANCELLED"})," until it is finally reset to the initial state, ",(0,r.jsx)(n.code,{children:"UNDETERMINED"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"active",children:"ACTIVE"}),"\n",(0,r.jsxs)(n.p,{children:["Handler has recognized a gesture. It will become and stay in the ",(0,r.jsx)(n.code,{children:"ACTIVE"})," state until the gesture finishes (e.g. when user lifts the finger) or gets cancelled by the touch system. Under normal circumstances the state will then turn into ",(0,r.jsx)(n.code,{children:"END"}),". In the case that a gesture is cancelled by the touch system, its state would then become ",(0,r.jsx)(n.code,{children:"CANCELLED"}),".\nLearn about ",(0,r.jsx)(n.a,{href:"/docs/gesture-handlers/about-handlers#discrete-vs-continuous",children:"discrete and continuous handlers here"})," to understand how long a handler can be kept in the ",(0,r.jsx)(n.code,{children:"ACTIVE"})," state."]}),"\n",(0,r.jsx)(n.h3,{id:"end",children:"END"}),"\n",(0,r.jsxs)(n.p,{children:["The gesture recognizer has received touches signalling the end of a gesture. Its state will become ",(0,r.jsx)(n.code,{children:"END"})," until it is reset to ",(0,r.jsx)(n.code,{children:"UNDETERMINED"}),"."]})]})}function o(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>d});var s=t(6540);const r={},a=s.createContext(r);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);